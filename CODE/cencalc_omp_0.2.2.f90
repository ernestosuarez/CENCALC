!       CONFORMATIONAL ENTROPY CALCULATION
!      
! Copyright (C) 2011 Ernesto Suarez Alvarez
!                    ernesto@fluor.quimica.uniovi.es
!                    ernesto.suarez.a@gmail.com
!
!   This program is free software: you can redistribute it and/or modify
!   it under the terms of the GNU General Public License as published by
!   the Free Software Foundation, either version 3 of the License, or
!   (at your option) any later version.
!
!   This program is distributed in the hope that it will be useful,
!   but WITHOUT ANY WARRANTY; without even the implied warranty of
!   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!   GNU General Public License for more details.
!
!   You should have received a copy of the GNU General Public License
!   along with this program.  If not, see <http://www.gnu.org/licenses/>.
!-----------------------------------------------------------------------------------------

!-----------------------------------------------------------------------------------------
!  Any use of the CENCALC software or derivative should include at least the following 
!  citation:
!
!  1)E. Suarez, N. Diaz, J. Mendez and D. Suarez. CENCALC: A Computational Tool for 
!    Conformational Entropy Calculations from Molecular Dynamics Simulations. 
!    J. Chem. Inf. Model. 2011, 
!
!  The methods implemented in CENCALC are fully described in the following references: 
!
!  2)E. Suarez, N. Diaz and D. Suarez. Entropy Calculations of Single Molecules by 
!    Combining the Rigidï€­Rotor and Harmonic-Oscillator Approximations with Conformational 
!    Entropy Estimations from Molecular Dynamics Simulations 
!    J. Chem. Theor. Comput. 2011 (Accepted).
!
!  3)E. Suarez, D. Suarez. Multibody Local Approximation: Application in the Conformational 
!    Entropy Calculation on Biomolecules.  2011 (submitted).
!
!  All questions regarding the usage and distribution of CENCALC or bug reports should be
!  addressed to Ernesto Suarez (ernesto@fluor.quimica.uniovi.es). 
!-----------------------------------------------------------------------------------------



!*****************************************************************************************
        MODULE parameters                                                                !
!*****************************************************************************************
        implicit none
        integer, parameter :: DP = selected_real_kind(16)
        integer, parameter :: SMALL = selected_int_kind(9)
        integer, parameter :: K4B=selected_int_kind(9)
        integer, parameter :: K4C=selected_int_kind(10)
        real(DP),parameter :: R=1.987                         !Gas Constant in cal/molK
        END module parameters
!-----------------------------------------------------------------------------------------



!     _____________________________
!    /|                           |
!    /|       MAIN PROGRAM        |
!    /|___________________________|
!    //////////////////////////////


!*****************************************************************************************     
      PROGRAM CENCALC_OMP                                                                !
!*****************************************************************************************
! cencalc_omp 
!
! This program computes the conformational entropy from the files generated by the program
!centro_prep: "MATRIX.dat" and "reduced_dist_matrix.dat"(if a cutoff criterion is applied).
!-----------------------------------------------------------------------------------------
!-----------------------------------------------------------------------------------------
! QUICK HELP:
!
! A quick help can be viewed from the command line by typing: 
! >> centro_omp -help 
!-----------------------------------------------------------------------------------------
      use parameters
      IMPLICIT NONE
      !-VARIABLE DEFINITIONS--------------------------------------------------------------
      integer NumCol                                          !Number of Columns(Dihedrals) selected in MATRIX.dat
      integer NumSnapIni                                      !Initial number of Snapshots
      integer NumSnapTot                                      !Total number of rows(Snapshots) to be considered 
      integer NumSnap                                         !Number of Snapshots used on each CALC 
      integer SnapInterval                                    !Gap in snapshots between consecutive calculations (CALCs)
      integer MaxOrder                                        !Maximum order of expansion (MIE, AMIE, ...)
      integer(SMALL),dimension (:,:),allocatable :: N(:,:)    !Data Matrix (by default, the content of MATRIX.dat)

      integer Method                                          !Method, the are 3 possible values for this variable:
                                                              ! 1 - MIE 
                                                              ! 2 - AMIE 
                                                              ! 3 - MLA or CCMLA (Correlation Corrected MLA)
                                                              !The discrimination between the two options in 3
                                                              !is done through the "FilterCorrelation" variable
                                                                        
      logical FilterCorrelation                               !Filter false correlation? (True/False)
                                                              !(Transforms MLA into CC-MLA)


      integer,dimension (:),allocatable :: X(:)               !Vector whose elements indicate the ordering
                                                              !of the columns in MATRIX.dat that would minimize
                                                              !the additional terms

      integer,dimension (:),allocatable :: invX(:)            !Inverse of X (i.e., invX(X(i))=i for every i)
                                                              
      integer,dimension (:,:),allocatable :: NeigList(:,:)    !Neighbors List. The i-row of this matrix contains
                                                              !the list Li={Ai,...} (see the main references of
                                                              !of the program)

      integer,dimension (:),allocatable :: NumNeig(:)         !Number of Neighbors of the i-element
      real(DP),dimension (:),allocatable :: ENTROPY(:)        !Entropy vs order: Entropy(Order) (MIE,AMIE)
      integer j,i,A,i1,C,k                                    !Counters
      integer MaxNumNeig                                      !Maximum number of neighbors observed
      real(DP) ENT_III                                        !MLA and/or CC-MLA Entropy
      real(DP) CutOff                                         !Cutoff
      real(DP) MaxDist                                        !Maximum value in the distance matrix
      real(DP) dummy                                          !Dummy real variable
      integer idummy,ios                                      !Dummy integer variables

      logical Reorder                                         !Change the ordering of the dihedrals
                                                              !in order to minimize the additional terms?
                                                              !(True/False)

      real(DP), dimension (:,:),allocatable :: DistIni(:,:)   !Reduced distance matrix before reordering 
      real(DP), dimension (:,:),allocatable :: DIST(:,:)      !Reduced distance matrix after reordering

      logical MakeCorrection                                  !Eliminate de additional terms up to de given
                                                              !MaxOrder? (True/False)              

      logical GivenNumCol                                     !Is the number of columns (NumCol) specified? (True/False)
      logical GivenNumSnap                                    !Is the number of snapshots specified? (True/False)
      logical GivenCutoff                                     !Is the cutoff specified? (True/False)

      character*60  filedist                                  !Filename of the distance matrix file 
                                                              !Default:reduced_dist_matrix.dat

      character*60  filedat                                   !Filename of the data file (Default: MATRIX.dat).
                                                              !This file contains the discretized evolution
                                                              !of the dihedral angles 

      character*60  filetable                                 !Filename of the file where the results are
                                                              !summarized in table form

      character*60  arg                                       !Dummy character variable
      character*8 Estimator                                   !Estimator: Max-Likelihood(-ml) or Chao-Shen(-cs)
      integer CALC                                            !Counter for the number of calculations
      real CpuTime1,CpuTime2,CpuTimeTot                       !CPU time variables
      integer(K4C) RTime1,RTime2,RT1,RT2,rate                 !Auxiliary variables to compute real-time
      real T_Temp                                             !Temporal variable where is saved real-time estimations
      real(DP),dimension (:),allocatable :: CORRECTION(:)     !Entropy Correction to eliminate the additional terms

      integer(K4B) idum                                       !Auxiliary variable for the random number generator
                                                              !in function "ran"
      !-----------------------------------------------------------------------------------


      write(*,'(A33)') " _______________________________ "
      write(*,'(A33)') "||  _____                       |"
      write(*,'(A33)') "||  \\   ||                     |"
      write(*,'(A33)') "||   \\    PROGRAM CENCALC_OMP  |"
      write(*,'(A33)') "||   //          v0.2           |"
      write(*,'(A33)') "||  //___||                     |"
      write(*,'(A33)') "||______________________________|"
      print*," "


      call system_clock(count=RTime1, count_rate=rate)


!---DEFAULT/INITIAL VALUES----------------------------------------------------------------
      idum=-1                                                 !Initialize idum for random       
                                                              !number generator in function ran
      filedat='MATRIX.dat'                                    
      filedist='reduced_dist_matrix.dat'                      
      filetable='TABLE.out'                                   
      CutOff=8.0                                                
      MaxOrder=4                                                
      GivenNumCol=.false.                                                   
      GivenNumSnap=.false.                                            
      GivenCutoff=.false.                                                   
      SnapInterval=1000                                               
      Method=3                                                  
      Reorder=.true.                                            
      MakeCorrection=.false.                                
      FilterCorrelation=.true.                               
      Estimator="ml"                                          
!-----------------------------------------------------------------------------------------

     
!---READING OPTIONS-----------------------------------------------------------------------
      CALL Read_Options(CutOff,MaxOrder,Method,filedat,filedist,filetable &
      ,NumSnap,NumSnapIni,NumCol,SnapInterval,GivenNumCol,GivenNumSnap,GivenCutoff&
      ,Reorder,Estimator,MakeCorrection,FilterCorrelation)
!-----------------------------------------------------------------------------------------


!---READING THE REDUCED-DISTANCE-MATRIX IF THE CUTOFF IS GREATER OR EQUAL ZERO------------
     if(CutOff.ge.0.0) then
      write(*,'(A30)')"Reading the distance matrix..."
      write(*,*)"filename: ",filedist
      MaxDist=0

      open(3,file=filedist,status='old',iostat=ios)           !Opening the distance matrix file
      if(ios.ne.0) then
       print*,"Error during opening of ",filedist
       stop
      endif

         if(.not.GivenNumCol) then                            !If NumCol is not specified, 
              C=0                                             !count how many columns there are
              ios=0
              do while(ios==0)
               read(3,'(F9.3)',iostat=ios,advance='no') dummy !Just to know the number of columns
               if(ios>0) then 
                print*,"Error(2) while reading(using format F9.3) ",filedist
                stop
               endif
               if(ios<0) exit
               C=C+1
              enddo
              rewind(3)
           
              A=0
              ios=0
              do while(ios==0)
                read(3,*,iostat=ios) dummy                    !Just to know the number of rows
                if(ios>0) stop "Error(3) while reading reduced_dist_matrix.dat"
                if(ios==-1) exit
                A=A+1
              enddo
              rewind(3)
           
              if(A.eq.C) then
                  NumCol=C
                  write(*,'(A26,I6)')   "Number of Colums and rows:",NumCol
              else
                  Stop "Error(4) The number of columns and rows are not the same"
              endif
         endif

      allocate(DistIni(NumCol,NumCol))  
      allocate(DIST(NumCol,NumCol))  
      allocate(X(NumCol))  
      allocate(invX(NumCol))  

      do i=1,NumCol
       X(i)=i                                                 !Initial values for X
       invX(i)=i                                              !and invX
      enddo

      do i=1,NumCol
        read(3,'(10000F9.3)',iostat=ios)(DistIni(i,j),j=1,NumCol)
        if(ios>0) then 
           print*,"Error(1) while reading ",filedist
           stop
        elseif(ios<0) then
           print*,"Error(1) Unexpected end of file or record"
           stop
        endif
      enddo

      if(Reorder) then                                        !Getting the real values for X
        CALL Get_Best_Ordering(DistIni,NumCol,CutOff,X,invX)  !and invX
      endif

      do i=1,NumCol
        do j=1,NumCol
         DIST(i,j)=DistIni(X(i),X(j))                         !Reordering the distance matrix
         if(DIST(i,j).gt.MaxDist) MaxDist=DIST(i,j)           !taking into account the vector X
        enddo
      enddo

     endif 
!-----------------------------------------------------------------------------------------


!---READING THE DATA MATRIX---------------------------------------------------------------
      write(*,*)" "
      write(*,'(A26)')"Reading the data matrix..."
      write(*,*)"filename: ",filedat
      open(2,file=filedat,status='old',iostat=ios)
      if(ios.ne.0) then
       print*,"Error during opening of ",filedat
       stop
      endif

      if(.not.GivenNumCol) then                               !If NumCol is not specified,
           A=0                                                !count how many columns there are
           ios=0
           do while(ios==0)
            read(2,'(I2)',iostat=ios,advance='no') idummy     !Just to know the number of columns
             if(ios>0) then
              print*,"Error(5) while reading(using format I2) ",filedat
              stop 
             endif
             if(ios<0) exit
            A=A+1
           enddo
           if((A.ne.NumCol).and.(CutOff.ge.0)) stop  &
           "Error(55) The number of columns of the distance matrix and &
            &the data file are not the same"
           NumCol=A
           print'(A18,I6)',"Number of Columns:",NumCol
      endif
      rewind(2)

      if(.not.GivenNumSnap) then                              !If NumSnap is not specified,
           A=0                                                !count how many rows there are
           ios=0                                              !in the data matrix
           do while(ios==0)
            read(2,*,iostat=ios) dummy                        !Just to know the number of snapshots(rows)
            if(ios>0) stop "Error(6) while reading the data file"
            if(ios==-1) exit
            A=A+1
           enddo
           NumSnap=A
           NumSnapIni=A
           print'(A27,I8)',"Number of Snapshots readed:",NumSnap
      endif
      rewind(2)

      allocate(N(NumSnap,NumCol)) !---------------------------!Once the exact number of columns and rows
                                                              !to be considered in the data matrix are
                                                              !known, then allocate N and save the info on it.
      do i=1,NumSnap 
        if(CutOff.ge.0.0) &  !--------------------------------!Read the data matrix taking into account the optimal
           read(2,'(10000I2)',iostat=ios)(N(i,invX(j)),j=1,NumCol)      !ordering given by X, or specifically, given by invX
        if(CutOff.lt.0.0) &  !--------------------------------!If cutoff<0 (infinite cutoff) read the data matrix                               
           read(2,'(10000I2)',iostat=ios)(N(i,j),j=1,NumCol)            !normally
        if(ios>0) then
           print*,"Error(7) while reading ",filedat
           stop
        elseif(ios<0) then
           print*,"Error(7) Unexpected end of ",filedat
           print*,"If you have specified the Num of Snapshots using -ns,"
           print*,"then check that the number of rows in ",filedat     
           print*,"is greater or equal than the specified Num of Snapshots"
           stop
        endif
      enddo
!-----------------------------------------------------------------------------------------


      allocate(ENTROPY(0:MaxOrder))
      allocate(CORRECTION(MaxOrder))


!---CALCULATING THE ENTROPY---------------------------------------------------------------
      write(*,*) " "
      write(*,'(A25)') "-------------------------"
      write(*,'(A25)') " CALCULATING THE ENTROPY "
      write(*,'(A25)') "-------------------------"
      print*, " "

      open(1,file=filetable,status='replace')
 
      if((MaxOrder.gt.NumCol).and.((Method.eq.1).or.(Method.eq.2))) then
        print*,"WARNING: Order is greater than the number of Columns"
        print*,"         NumColumns will be taken as MaxOrder"
        MaxOrder=NumCol
      endif

      if(CutOff.gt.MaxDist) then
       print*,&
       "WARNING: CutOff bigger than MaxDistance in Distance Matrix"
       print*,"         no CutOff will be applied"
       CutOff=-1
      endif

      if(CutOff.ge.0.0) then
          allocate(NumNeig(NumCol))
          allocate(NeigList(NumCol,NumCol))
          CALL Get_Neighbors_Info(DIST,NumCol,CutOff,NeigList,NumNeig)
        else
          allocate(NumNeig(NumCol))
          allocate(NeigList(NumCol,NumCol))
      endif

      NumSnapTot=NumSnap !------------------------------------!Actually, at this point NumSnap is the total
                                                              !number of snapshots considered, that's why 
                                                              !we save its value in NumSnapTot. 
      CALC=0

      do NumSnap=NumSnapIni,NumSnapTot,SnapInterval !---------!Compute the entropy from NumSnapIni snapshots
                                                              !to NumSnapTot, every SnapInterval
          call random_seed()
          CALC=CALC+1 
          call cpu_time(CpuTime1)
          call system_clock(count=RT1)

          print*, ' '  !                                      \
          print'(A5,I3)',  "CALC:",CALC                       !
          print'(A25)',  "========================="          !
          if(Estimator.eq."cs") &                             !
             print'(A25)', "Estimator:      Chao-Shen"        ! 
          if(Estimator.eq."ml") &                             !
             print'(A25)', "Estimator: Max-Likelihood"        !       
          if(Method.eq.1) then                                ! 
             print'(A17,A8)',  "Method:          ","MIE"      !
          else if(Method.eq.2) then                           !
             print'(A17,A8)',  "Method:          ","AMIE" !    > Write the preamble of the output
          else                                                !  (input data)
           if(FilterCorrelation)&                             !
             print'(A17,A8)',  "Method:          ","CC-MLA"   !
           if(.not.FilterCorrelation)&                        !
             print'(A17,A8)',  "Method:          ","MLA"      !
          endif                                               !
          print'(A17,F8.3)',"Cut-Off:         ",CutOff        !
          print'(A17,I8)',  "Num of Snapshots:",NumSnap       !
          print'(A17,I8)',  "Num of columns  :",NumCol        ! 
          if((Method.eq.1).or.(Method.eq.2)) &                !
             print'(A17,I8)',  "Maximum Order:   ",MaxOrder ! /
  

          !---------------------------------------------------!Compute the entropy
          if(CutOff.ge.0.0) then
            if(Method.eq.2) then
              CALL AMIE_CutOff(N,DIST,NeigList,NumNeig, &
              NumSnap,NumSnapTot,NumCol,MaxOrder,MaxNumNeig,ENTROPY,Estimator)
              if(MakeCorrection) then
                print*," "
                print'(A39,I3,A3)',&
                "ELIMINATING ADITIONAL TERMS UP TO ORDER",MaxOrder,"..."
                CALL Elim_Additional_Terms(N,DIST,NeigList,NumNeig, &
                CutOff,NumSnap,NumSnapTot,NumCol,MaxOrder,MaxNumNeig,CORRECTION,Estimator)
                do I=1,MaxOrder
                  ENTROPY(I)=ENTROPY(I)-CORRECTION(I)
                enddo
                print'(A42,F12.4)',&
                "ENTROPY SUBTRACTED AT MAXORDER(cal/mol-K):",CORRECTION(MaxOrder)
              endif
            elseif(Method.eq.1) then
              CALL MIE_CutOff(N,DIST,NeigList,NumNeig, &
              CutOff,NumSnap,NumSnapTot,NumCol,MaxOrder,MaxNumNeig,ENTROPY,Estimator)
            elseif(Method.eq.3) then
              if(.not.FilterCorrelation) then
               !Normal calculation with method 3
               CALL MLA_CutOff(N,NumSnap,NumSnapTot,NumCol,NeigList,NumNeig,MaxNumNeig,ENT_III,CutOff,Estimator)
              else
               !Filtering false correlation in method 3
               CALL CCMLA_CutOff(N,NumSnap,NumSnapTot,NumCol,NeigList,NumNeig,MaxNumNeig,ENT_III,CutOff,Estimator,idum)
              endif
              if(MakeCorrection) then
                print*," "
                print'(A39,I3,A3)',&
                "ELIMINATING ADITIONAL TERMS UP TO ORDER",MaxOrder,"..."
                CALL Elim_Additional_Terms(N,DIST,NeigList,NumNeig, &
                CutOff,NumSnap,NumSnapTot,NumCol,MaxOrder,MaxNumNeig,CORRECTION,Estimator)
                ENT_III=ENT_III-CORRECTION(MaxOrder)
                print'(A30,F12.4)',"ENTROPY SUBTRACTED(cal/mol-K):",CORRECTION(MaxOrder)
              endif
            else
              print*,"ERROR: Check the method. Use -help for more info"
              stop
            endif
          else
            if((Method.eq.3).and.(FilterCorrelation)) then
             CALL CCMLA_NoCutOff(N,NumSnap,NumSnapTot,NumCol,ENT_III,Estimator,idum)
            elseif((Method.eq.3).and.(.not.FilterCorrelation)) then
             CALL MLA_NoCutOff(N,NumSnap,NumSnapTot,NumCol,ENT_III,Estimator)
            elseif((Method.eq.1).or.(Method.eq.2)) then
             CALL MIE_NoCutOff(N,NumSnap,NumSnapTot,NumCol,MaxOrder,ENTROPY,Estimator)
            endif
          endif
         !------------------------------------------------------------------

         !----------------------------------------------------!Write Results
         if((Method.eq.1).or.(Method.eq.2)) then  
          write(*,*) " "
          write(*,'(A43)') "ESTIMATED ENTROPY vs ORDER(cal/mol-Kelvin):"
          write(*,'(A43)') "-------------------------------------------"
          write(*,'(A9,50A12)') "# NumSnap", ("ORDER",I=1,MaxOrder)
          write(*,'(A9,50I12)') "         ", (I,I=1,MaxOrder)
          write(*,'(I9,50F12.4)') NumSnap, (ENTROPY(I),I=1,MaxOrder)
          print'(A4)',"DONE"
          if(NumSnap==NumSnapIni) then
            write(1,'(A9,50A12)') "# NumSnap", ("ORDER",I=1,MaxOrder)
            write(1,'(A9,50I12)') "#        ", (I,I=1,MaxOrder)
          endif
          write(1,'(I9,50F12.4)') NumSnap, (ENTROPY(I),I=1,MaxOrder)
         elseif(Method.eq.3) then
          write(*,*) " "
          write(*,'(A43)') "ESTIMATED ENTROPY (cal/mol-Kelvin)         "
          write(*,'(A43)') "-----------------------------------        "
          write(*,'(A9,A12)') "# NumSnap","Entropy"
          write(*,'(I9,50F12.4)') NumSnap, ENT_III
          if((Estimator.eq."cs").and.(ENT_III.eq.0.0)) then
          print*,"WARNING: A zero value of entropy using Chao-Shen estimator could be"
          print*,"         due to a poor sampling, if the Number of Snapshots is equal"
          print*,"         to the Number of Singletons, the corrected probability will"
          print*,"         be zero, and hence the entropy will be zero as well."
          endif
          print'(A4)',"DONE"
          if(NumSnap==NumSnapIni) &
           write(1,'(A9,A12)') "# NumSnap", "Entropy"
          write(1,'(I9,50F12.4)') NumSnap, ENT_III
         endif
         call cpu_time(CpuTime2)
         call system_clock(count=RT2)
         T_Temp=real(RT2-RT1)/rate
         write(*,'(A26,I3,A1,F11.2,A8,F9.2,A6)')" Partial cpu-time for CALC",&
              CALC,":",CpuTime2-CpuTime1," seconds",((CpuTime2-CpuTime1)/3600.)," hours"
         write(*,'(A26,I3,A1,F11.2,A8,F9.2,A6)')"Partial real-time for CALC",&
              CALC,":",T_Temp," seconds",(T_Temp/3600.)," hours"
         print*," "
      enddo
      close(1)
      close(2)
      close(3)

      !-------------------------------------------------------!Write the computational cost
      call cpu_time(CpuTimeTot)
      call system_clock(count=RTime2)
      T_Temp=real(RTime2-RTime1)/rate
      write(*,'(A30,F11.2,A8,F9.2,A6)')"TOTAL CPU-TIME :",&
           CpuTimeTot," seconds",(CpuTimeTot/3600.)," hours"
      write(*,'(A30,F11.2,A8,F9.2,A6)')"TOTAL REAL-TIME:",&
           T_Temp," seconds",(T_Temp/3600.),"hours"

      STOP                                                    !----------FINISH-----------
!-----------------------------------------------------------------------------------------
      END PROGRAM CENCALC_OMP                                                            !
!-----------------------------------------------------------------------------------------



!      _____________________________
!     /|                           |
!     /| SUBROUTINES AND FUNCTIONS |
!     /|___________________________|
!     //////////////////////////////


!*****************************************************************************************
      SUBROUTINE MLA_CutOff(N,NumSnap,NumSnapTot,NumCol,NeigList,NumNeig,MaxNumNeig&
      ,Entropy,CutOff,Estimator)
!*****************************************************************************************
!As the name implies, this subroutine compute the MLA entropy 
!using the given cutoff
!-----------------------------------------------------------------------------------------
      use parameters
      implicit none
      !-VARIABLE DEFINITIONS--------------------------------------------------------------
      integer NumCol                                          !Number of columns (dihedrals)
      integer NumSnap                                         !Number of snapshots in the current CALC
      integer NumSnapTot                                      !Total number of snapshots considered
      integer MaxNumNeig                                      !Max number of neighbors observed
      integer(SMALL) N(NumSnapTot,NumCol)                     !Data Matrix
      integer(SMALL),dimension (:,:),allocatable ::  M(:,:)   !Auxiliary data matrix
      integer NeigList(NumCol,MaxNumNeig)                     !Neighbors Lists. The i-row contains
                                                              !the list Li={Ai,...} (see ref.(3))
      integer X(NumCol)                                       !Temporal variable where is saved when needed
                                                              !one of the lists Li={Ai,...} (see ref.(3)
      integer NumNeig(NumCol)                                 !Number of Neighbors of the i-element(Ai)
      real(DP),intent(out)::Entropy                           !Entropy 
      integer i,j,I2,I3,i4                                    !Counters
      real(DP) CutOff                                         !CutOff
      character*8 Estimator                                   !Estimator
      logical finish,founded                                  !Auxiliary logical variables
      integer iprevious,Limit                                 !Auxiliary integer variables
      real(DP),dimension (:),allocatable :: ENT1              !S(Li) see ref. (3)
      real(DP),dimension (:),allocatable :: ENT2              !S(Li-{Ai}) see ref. (3)
      !-----------------------------------------------------------------------------------

      !--Initial values
      Entropy=0
      iprevious=0
      write(*,*) "          ..."
      finish=.false.
      founded=.false.

      allocate(M(NumSnap,NumCol))
      allocate(ENT1(NumCol))
      allocate(ENT2(NumCol))

      do i=1,NumCol
        ENT1(i)=0
        ENT2(i)=0
        if ((NumNeig(i).eq.(NumCol-i)).and.(.not.founded)) then
         Limit=i
         founded=.true.
        endif
      enddo

!$omp parallel private(i,j,I2,I3,X,M) firstprivate(finish)
!!$      allocate(M(NumSnap,NumCol))
!$omp do schedule(dynamic)
      do i=1,Limit
           X(NumNeig(i)+1)=i
           do j=1,NumNeig(i)
            X(j)=NeigList(i,j)
           enddo
           do I3=1,NumSnap
             do I2=1,NumNeig(i)+1
               M(I3,I2)=N(I3,X(I2))
             enddo
           enddo
           CALL ENTRO(M,NumSnap,NumNeig(i)+1,ENT1(i),Estimator)
           if (i.ne.Limit) then
            CALL ENTRO(M,NumSnap,NumNeig(i),ENT2(i),Estimator)
           else
            ENT2(i)=0.
           endif
        if((10*i/Limit).gt.iprevious) then
           write(*,*) 10*(iprevious+1),"%"
           iprevious=10*i/Limit
        endif
      enddo
!!$    deallocate(M)
!$omp end parallel
        
      do i=1,NumCol
         Entropy=Entropy+(ENT1(i)-ENT2(i))
      enddo

      deallocate(M)
      deallocate(ENT1)
      deallocate(ENT2)
      return
      END SUBROUTINE MLA_CutOff
!-----------------------------------------------------------------------------------------



!*****************************************************************************************
      SUBROUTINE CCMLA_CutOff(N,NumSnap,NumSnapTot,NumCol,NeigList,NumNeig,MaxNumNeig&
      ,Entropy,CutOff,Estimator,idum)
!*****************************************************************************************
!As the name implies, this subroutine compute the CCMLA entropy 
!using the given cutoff
!-----------------------------------------------------------------------------------------
      use parameters
      implicit none
      !-VARIABLE DEFINITIONS--------------------------------------------------------------
      integer NumCol                                          !Number of columns (dihedrals)
      integer NumSnap                                         !Number of snapshots in the current CALC
      integer NumSnapTot                                      !Total number of snapshots considered
      integer MaxNumNeig                                      !Max number of neighbors observed
      integer(SMALL),intent(in)::N(NumSnapTot,NumCol)         !Data Matrix

      integer(SMALL),dimension (:,:),allocatable :: NewN(:,:) !The data matrix after random reordering
                                                              !of the elements of its columns.

      integer(SMALL),dimension(:),allocatable :: M1           !A column matrix used to compute marginal Ent.

      integer(SMALL),dimension (:,:),allocatable ::  M(:,:)   !Auxiliary data matrix to compute Ent.
                                                              !of subsets of N

      integer(SMALL),dimension (:,:),allocatable :: NewM(:,:) !The matrix M after random reordering
                                                              !of the elements of its columns

      integer NeigList(NumCol,MaxNumNeig)                     !Neighbors Lists. The i-row contains
                                                              !the list Li={Ai,...} (see ref.(3))

      integer X(NumCol)                                       !Temporal variable where is saved when needed
                                                              !one of the lists Li={Ai,...} (see ref.(3)

      integer NumNeig(NumCol)                                 !Number of Neighbors of the i-element(Ai)
      real(DP),intent(out)::Entropy                           !Entropy 
      integer i,j,i2,i3,i4                                    !Counters
      real(DP) CutOff                                         !CutOff

      real(DP) ENT1_1                                         !S(Li) see ref(3) for notations
      real(DP) ENT1_2                                         !S'(Li) see ref(3) for notations
      real(DP) ENT2_1                                         !S(Li-Ai) see ref(3) for notations
      real(DP) ENT2_2                                         !S'(Li-Ai) see ref(3) for notations
      real(DP),dimension (:),allocatable :: ENT1              !ENT1(i)=S(Li)-S'(Li) 
      real(DP),dimension (:),allocatable :: ENT2              !ENT2(i)=S(Li-Ai)-S'(Li-Ai)

      integer,dimension (:),allocatable :: RandRow(:)         !A vector where the components are selected
                                                              !randomly without replacement from {1,...,NumSnap}  

      real(DP),dimension (:),allocatable :: S1(:)             !Vector where is saved the marginal entropies
      integer iprevious,Limit                                 !Auxiliary integer variables
      character*8 Estimator                                   !Estimator
      logical finish,founded                                  !Auxiliary logical variables

      integer(K4B), intent(inout) :: idum                     !Auxiliary variable for the random number generator
                                                              !in in function "ran"
      !-----------------------------------------------------------------------------------

      !Initial values
      Entropy=0
      iprevious=0
      finish=.false.
      founded=.false.
      
      !-Allocating
      allocate(M(NumSnap,NumCol))
      allocate(ENT1(NumCol))
      allocate(ENT2(NumCol))
      allocate(S1(NumCol))
      allocate(M1(NumSnap))
      allocate(RandRow(NumSnap))
      allocate(NewN(NumSnap,NumCol))
      allocate(NewM(NumSnap,NumCol))

      do i=1,NumSnap
        RandRow(i)=i
      enddo

      !-Obtaining NewN
      do j=1,NumCol
       call Randomize_Row(RandRow,NumSnap,idum)
       do i=1,NumSnap
        NewN(i,j)=N(RandRow(i),j)
       enddo
      enddo

      do i=1,NumCol 
        ENT1(i)=0
        ENT2(i)=0
        if ((NumNeig(i).eq.(NumCol-i)).and.(.not.founded)) then
         Limit=i
         founded=.true.
        endif
      enddo
      
      !-Computing the marginal entropies
      do j=1,NumCol
        do i=1,NumSnap
         M1(i)=N(i,j)
        enddo
        CALL ENTRO(M1,NumSnap,1,S1(j),Estimator) !!!!
      enddo

      write(*,*) "          ..."

!$omp parallel private(i,j,I2,I3,X,NewM,M,ENT1_1,ENT1_2,ENT2_1,ENT2_2) firstprivate(finish)
!!$      allocate(M(NumSnap,NumCol))
!!$      allocate(NewM(NumSnap,NumCol))
!$omp do schedule(dynamic)
      do i=1,NumCol
           X(NumNeig(i)+1)=i
           do j=1,NumNeig(i)
            X(j)=NeigList(i,j)
           enddo
           do I3=1,NumSnap
             do I2=1,NumNeig(i)+1
               M(I3,I2)=N(I3,X(I2))
             enddo
           enddo
           do I3=1,NumSnap
             do I2=1,NumNeig(i)+1
               NewM(I3,I2)=NewN(I3,X(I2))
             enddo
           enddo
           ENT1_1=0
           ENT1_2=0
           ENT1(i)=0
           !--------------------------------------------------!Computing S(Li) and S'(Li)
           CALL ENTRO(M,NumSnap,(NumNeig(i)+1),ENT1_1,Estimator) 
           CALL ENTRO(NewM,NumSnap,(NumNeig(i)+1),ENT1_2,Estimator)
           ENT1(i)=ENT1_1-ENT1_2
           ENT2_1=0
           ENT2_2=0
           ENT2(i)=0
           if ((i.ne.NumCol).and.(NumNeig(i).ne.0)) then
           !--------------------------------------------------!Computing S(Li-Ai) and S'(Li-Ai)
            CALL ENTRO(M,NumSnap,NumNeig(i),ENT2_1,Estimator)
            CALL ENTRO(NewM,NumSnap,NumNeig(i),ENT2_2,Estimator)
            ENT2(i)=ENT2_1-ENT2_2
           else
            ENT2(i)=0
           endif
        if((10*i/NumCol).gt.iprevious) then
           write(*,*) 10*(iprevious+1),"%"
           iprevious=10*i/NumCol
        endif
      enddo
!!$    deallocate(M)
!!$    deallocate(NewM)
!$omp end parallel

      do i=1,NumCol
       Entropy=Entropy+S1(i)+(ENT1(i)-ENT2(i))                !Finally, computing the CC-MLA Entropy
      enddo

      deallocate(M)
      deallocate(ENT1)
      deallocate(ENT2)
      deallocate(S1)
      deallocate(RandRow)
      deallocate(NewN)
      deallocate(NewM)
      return
      END SUBROUTINE CCMLA_CutOff
!-----------------------------------------------------------------------------------------



!*****************************************************************************************
      SUBROUTINE MLA_NoCutOff(N,NumSnap,NumSnapTot,NumCol,Entropy,Estimator)
!*****************************************************************************************
! Since MLA for infinite cutoff is the exact sample entropy, this subroutine 
!computes the sample entropy without any further approximation.
!-----------------------------------------------------------------------------------------
      use parameters
      implicit none
      !-VARIABLE DEFINITIONS--------------------------------------------------------------
      integer NumCol                                          !Number of columns (dihedrals)
      integer NumSnap                                         !Number of snapshots in the current CALC
      integer NumSnapTot                                      !Total number of snapshots considered
      integer(SMALL) N(NumSnapTot,NumCol)                     !Data matrix
      integer(SMALL),dimension (:,:),allocatable :: M(:,:)    !Auxiliary data matrix
      character*8 Estimator                                   !Estimator
      real(DP) Entropy                                        !Sample entropy
      integer i,j
      !-----------------------------------------------------------------------------------
 
      allocate(M(NumSnap,NumCol))

      do i=1,NumSnap
       do j=1,NumCol
        M(i,j)=N(i,j)
       enddo
      enddo

      CALL ENTRO(M,NumSnap,NumCol,Entropy,Estimator)          !Computing the sample entropy using
                                                              !NumSnap points
      deallocate(M)

      return
      END SUBROUTINE MLA_NoCutOff
!-----------------------------------------------------------------------------------------



!*****************************************************************************************
      SUBROUTINE CCMLA_NoCutOff(N,NumSnap,NumSnapTot,NumCol,Entropy,Estimator,idum)
!*****************************************************************************************
! Compute the correlation corrected entropy without cutoff 
!-----------------------------------------------------------------------------------------
      use parameters
      implicit none
      !-VARIABLE DEFINITIONS--------------------------------------------------------------
      integer NumCol                                          !Number of columns (dihedrals)
      integer NumSnap                                         !Number of snapshots in the current CALC
      integer NumSnapTot                                      !Total number of snapshots considered
      integer(SMALL) N(NumSnapTot,NumCol)                     !Data Matrix
      integer(SMALL),dimension (:,:),allocatable :: M(:,:)    !Auxiliary data matrix
      real(DP) EntroM                                         !Entropy of M

      integer(SMALL),dimension (:,:),allocatable :: NewM(:,:) !The matrix M after random reordering
                                                              !of the elements of its columns

      real(DP) EntroNewM                                      !Entropy of NewM

      integer(SMALL),dimension (:),allocatable :: TempColumn  !Temporal column matrix used to compute
                                                              !marginal entropies

      real(DP) S1                                             !Marginal entropy computed from TempColumn

      real(DP) SumMarginals                                   !Sum of marginal entropies

      integer,dimension (:),allocatable :: RandRow(:)         !A vector where the components are selected
                                                              !randomly without replacement from {1,...,NumSnap}  

      integer(K4B), intent(inout) :: idum                     !Auxiliary variable for the random number generator
                                                              !in in function "ran"

      character*8 Estimator                                   !Estimator
      real(DP) Entropy                                        !Correlation corrected Entropy
      integer i,j                                             !
      !-----------------------------------------------------------------------------------
 
      allocate(M(NumSnap,NumCol))
      allocate(NewM(NumSnap,NumCol))
      allocate(TempColumn(NumSnap))
      allocate(RandRow(NumSnap)) !!!!

      do j=1,NumCol
       do i=1,NumSnap
        M(i,j)=N(i,j)
       enddo
      enddo

      do i=1,NumSnap
       RandRow(i)=i
      enddo

      SumMarginals=0 

      do j=1,NumCol
       call Randomize_Row(RandRow,NumSnap,idum)
       do i=1,NumSnap
         NewM(i,j)=M(RandRow(i),j)
         TempColumn(i)=M(i,j)
       enddo
       CALL ENTRO(TempColumn,NumSnap,1,S1,Estimator)
       SumMarginals=SumMarginals+S1
      enddo

      CALL ENTRO(M,NumSnap,NumCol,EntroM,Estimator)
      CALL ENTRO(NewM,NumSnap,NumCol,EntroNewM,Estimator)
      
      Entropy=SumMarginals+EntroM-EntroNewM                   !Correlation corrected entropy calculation

      deallocate(M)
      deallocate(NewM)
      deallocate(TempColumn)
      deallocate(RandRow)

      RETURN
      END SUBROUTINE CCMLA_NoCutOff
!-----------------------------------------------------------------------------------------



!*****************************************************************************************
      SUBROUTINE AMIE_CutOff(N,DIST,NeigList,NumNeig, &
      NumSnap,NumSnapTot,NumCol,MaxOrder,MaxNumNeig,ENTROPY,Estimator)
!*****************************************************************************************
! This subroutine compute the Approximate Mutual Information Expansion (AMIE) using
!the given cutoff.(see ref(1))
!-----------------------------------------------------------------------------------------
      use parameters
      implicit none
      !-VARIABLE DEFINITIONS--------------------------------------------------------------
      integer NumCol                                          !Number of columns (dihedrals)
      integer NumSnap                                         !Number of snapshots in the current CALC
      integer NumSnapTot                                      !Total number of snapshots considered
      integer MaxOrder                                        !Order of the AMIE expansion
      integer(SMALL) N(NumSnapTot,NumCol)                     !Data matrix
      integer(SMALL),dimension (:,:),allocatable :: M(:,:)    !Auxiliary data matrix
      integer NeigList(NumCol,MaxNumNeig)                     !Neighbors list
      integer NumNeig(NumCol)                                 !Number of neighbors of the i-element
      integer MaxNumNeig                                      !Max number of neighbors
      real(DP) ENTROPY(0:MaxOrder)                            !Entropy vs Order: ENTROPY(Order) 
      real(DP) DIST(NumCol,NumCol)                            !Reduced distance matrix 
      character*8 Estimator                                   !Estimator
      logical LOGIC                                           !Auxiliary logic variable
      integer iprevious,VAR                                   !Auxiliary integer variables
      integer j,i,A,i1,k,i2,i3                                !Counters

      integer X(NumCol)                                       !Auxiliary vectors to generate 
      integer X1(NumCol)                                      !combinations

      real(DP) SUMA(MaxOrder,NumCol)                          !We denote as SUMA(i,k), the inner sum 
                                                              !in the AMIE expression,i.e.:
                                                              !    ___
                                                              !    \   { S(AiUJ) - S(J) }
                                                              !    /__
                                                              ! Jc(Li-Ai)
                                                              !  |J|=k-1
                                                              !
                                                              !(see ref(1))

      real(DP) ENT1                                           ! S(AiUJ) in the last expression
      real(DP) ENT2                                           ! S(J) in the last expression

      integer COEFF                                           !Coefficient in square brackets in 
                                                              !the AMIE expression, i.e.:
                                                              !    ___
                                                              !    \   ((-1)**j) binomial{|Li|-k,j}
                                                              !    /__          
                                                              ! j=0,...,n-k    
                                                              !

!$    integer C,Num_threads,my_thread
!$    integer omp_get_num_threads 
!$    integer omp_get_thread_num
      !-----------------------------------------------------------------------------------

      allocate(M(NumSnap,MaxOrder)) 

      do A=1,MaxOrder
       do k=1,NumCol
        SUMA(A,k)=0.0
       enddo
      enddo

      do A=1,MaxOrder
         iprevious=0
         if(A.ge.2) then
           write(*,*) " "
           write(*,'(A7,I3,A4)') "ORDER =",A," ..."
         endif
           if (A.eq.1) then
!$omp parallel private(M,i,k,ENT1,X)
!!$           allocate(M(NumSnap,MaxOrder))
!$omp do
            do k=1,NumCol
                X(1)=k
                do i=1,NumSnap
                  M(i,1)=N(i,k)
                enddo
                CALL ENTRO(M,NumSnap,1,ENT1,Estimator)
                SUMA(1,k)=SUMA(1,k)+ENT1
            enddo
!$omp end do
!!$           deallocate(M)
!$omp end parallel
           else
            do k=1,NumCol
                if(A.le.(NumNeig(k)+1)) then
                     do i=1,(A-1)
                      X(i)=i
                     enddo
                     X1(A)=k
                     do i=1,(A-1)
                      X1(i)=NeigList(k,X(i))
                     enddo
!$omp parallel do private(I3,I2)
                          do I3=1,NumSnap
                            do I2=1,A
                              M(I3,I2)=N(I3,X1(I2))
                            enddo
                          enddo
!$omp end parallel do

!$omp parallel sections
!$omp section
                          CALL ENTRO(M,NumSnap,A,ENT1,Estimator)
!$omp section
                          CALL ENTRO(M,NumSnap,A-1,ENT2,Estimator)
!$omp end parallel sections

                          SUMA(A,k)=SUMA(A,k)+(ENT1-ENT2)

!$omp parallel private(i,j,LOGIC,i1,I2,I3,X1,M,ENT1,ENT2,my_thread,C) firstprivate(X)
!!$       allocate(M(NumSnap,MaxOrder)) 
!$       Num_threads=omp_get_num_threads()
!$       my_thread=omp_get_thread_num()
!$       C=0
                      LOGIC=.true.
                     do while (LOGIC)
                       LOGIC=.false.
                       do i=(A-1),1,-1
                        if(X(i).LT.(i+NumNeig(k)-(A-1))) then
                         X(i)=X(i)+1
                           do j=1,(A-1)-i
                            X(i+j)=X(i)+j
                           enddo
!$                      if(my_thread.eq.C) then   
                           X1(A)=k
                           do i1=1,(A-1)
                            X1(i1)=NeigList(k,X(i1))
                           enddo
                          do I3=1,NumSnap
                            do I2=1,A
                              M(I3,I2)=N(I3,X1(I2))
                            enddo
                          enddo
                           CALL ENTRO(M,NumSnap,A,ENT1,Estimator)
                           CALL ENTRO(M,NumSnap,A-1,ENT2,Estimator)
!$omp critical
                           SUMA(A,k)=SUMA(A,k)+(ENT1-ENT2)
!$omp end critical
!$                      endif
!$               if(C.lt.(Num_threads-1)) then
!$                 C=C+1
!$               else
!$                 C=0
!$               endif

                         LOGIC=.TRUE.
                         exit
                        endif
                       enddo
                     enddo
!!$       deallocate(M) 
!$omp end parallel
                endif
                if((10*k/NumCol).gt.iprevious) then
                  write(*,*) 10*(iprevious+1),"%"
                  iprevious=10*k/NumCol
                endif
            enddo
           endif 
        
        ENTROPY(A)=0

        do k=1,NumCol
          do I=1,A
           VAR=NumNeig(k)+1
           CALL Coefficient(VAR,A,i,COEFF)
           ENTROPY(A)=ENTROPY(A)+COEFF*SUMA(I,k)
          enddo
        enddo
        if(A.eq.1) then
          print*," "
          write(*,'(A26,F16.4,A17)') "SUM OF MARGINAL ENTROPIES:",ENTROPY(A)," (cal/mol-Kelvin)"
        elseif(A.eq.2) THEN
          WRITE(*,'(I6,A20,F16.4)') A,"nd-ORDER CORRECTION:",ENTROPY(A)-ENTROPY(A-1)
        elseif(A.eq.3) THEN
          WRITE(*,'(I6,A20,F16.4)') A,"rd-ORDER CORRECTION:",ENTROPY(A)-ENTROPY(A-1)
        else
          WRITE(*,'(I6,A20,F16.4)') A,"th-ORDER CORRECTION:",ENTROPY(A)-ENTROPY(A-1)
        endif
      enddo
      RETURN

      END SUBROUTINE AMIE_CutOff
!-----------------------------------------------------------------------------------------



!*****************************************************************************************
      SUBROUTINE MIE_CutOff(N,DIST,NeigList,NumNeig, &
      CutOff,NumSnap,NumSnapTot,NumCol,MaxOrder,MaxNumNeig,ENTROPY,Estimator)
!*****************************************************************************************
! Compute the conformational entropy using the method MIE and a cutoff criterion
!-----------------------------------------------------------------------------------------
      use parameters
      implicit none
      !-VARIABLE DEFINITIONS--------------------------------------------------------------
      integer,intent(IN):: NumCol                             !Number of columns (dihedrals)
      integer,intent(IN):: NumSnap                            !Number of snapshots in the current CALC
      integer,intent(IN):: NumSnapTot                         !Total number of snapshots considered
      integer,intent(IN):: MaxOrder                           !Order of the MIE expansion
      integer(SMALL),intent(IN):: N(NumSnapTot,NumCol)        !Data matrix
      integer,intent(IN):: NeigList(NumCol,MaxNumNeig)        !Neighbors list
      integer,intent(IN):: NumNeig(NumCol)                    !Number of neighbors of the i-element
      integer,intent(IN):: MaxNumNeig                         !Max number of neighbors
      real(DP),intent(OUT)::ENTROPY(0:MaxOrder)               !Entropy vs Order: ENTROPY(Order) 
      integer j,i,A,i1,k                                      !Counters
      real(DP),intent(IN):: CutOff                            !Cutoff
      logical LOGIC,GeomOk                                    !Auxiliary logic variables
      integer iprevious                                       !Auxiliary integer variable
      real(DP),intent(IN)::DIST(NumCol,NumCol)                !Reduced distance matrix
      character*8 Estimator                                   !Estimator

      integer X(NumCol)                                       !Auxiliary vectors to generate
      integer Xnew(NumCol)                                    !combinations

      real(DP) Pseudo_MI                                      !For a given order k, and a subset J of 
                                                              !k dihedrals, Pseudo_MI=((-1)^(k-1))*Ik(J)
                                                              !where Ik(J) is the mutual information (MI)
                                                              !shared among the k dihedrals of J.                           

      real(DP) SUMA(MaxOrder)                                 !For a given order k, SUMA(k) is equal
                                                              !to:
                                                              !                ___
                                                              !   ((-1)^(k-1)) \   Ik(J)
                                                              !                /__
                                                              !             J .belongs. C(R)
                                                              !               |J|=k
                                                              !(see ref.(1))
!$    integer C,Num_threads,my_thread
!$    integer omp_get_num_threads 
!$    integer omp_get_thread_num
      !-----------------------------------------------------------------------------------
      
      do A=1,MaxOrder
       SUMA(A)=0. 
      enddo

      do A=1,MaxOrder
         if(A.ge.2) then
           write(*,*) " "
           write(*,'(A7,I3,A4)') "ORDER =",A," ..."
         endif

         if (A.eq.1) then
!$omp parallel do private(i,X,Pseudo_MI)
             do i=1,NumCol
              X(1)=i
              CALL Pseudo_Mutual_Info(X,A,N,NumSnap,NumSnapTot,NumCol,Pseudo_MI,Estimator)  
!$omp critical
              SUMA(A)=SUMA(A)+Pseudo_MI
!$omp end critical
             enddo
!$omp end parallel do
         else
             iprevious=0

             do k=1,NumCol
              if(A.le.(NumNeig(k)+1)) then
                   do i=1,(A-1)
                    X(i)=i
                   enddo
                   Xnew(1)=k
                   do i=1,(A-1)
                    Xnew(i+1)=NeigList(k,X(i))
                   enddo
                         CALL CheckGeom(Xnew,A,DIST,NumCol,CutOff,GeomOk) 
                         if (GeomOk) then
                           CALL Pseudo_Mutual_Info(Xnew,A,N,NumSnap,NumSnapTot,NumCol,Pseudo_MI,Estimator)  
                           SUMA(A)=SUMA(A)+Pseudo_MI                  
                         endif
!$omp parallel private(i,j,LOGIC,i1,Pseudo_MI,Xnew,my_thread,C,GeomOk) firstprivate(X)
!$       Num_threads=omp_get_num_threads()
!$       my_thread=omp_get_thread_num()
!$       C=0
                    LOGIC=.true.
                    do while (LOGIC)
                     LOGIC=.false.
                     do i=(A-1),1,-1
                      if(X(i).LT.(i+NumNeig(k)-(A-1))) then
                       X(i)=X(i)+1
                         do j=1,(A-1)-i
                          X(i+j)=X(i)+j
                         enddo
!$                     if(my_thread.eq.C) then                    
                         Xnew(1)=k
                         do i1=1,(A-1)
                          Xnew(i1+1)=NeigList(k,X(i1))
                         enddo
                         CALL CheckGeom(Xnew,A,DIST,NumCol,CutOff,GeomOk)
                         if (GeomOk) then
                           CALL Pseudo_Mutual_Info(Xnew,A,N,NumSnap,NumSnapTot,NumCol,Pseudo_MI,Estimator)
!$omp critical
                           SUMA(A)=SUMA(A)+Pseudo_MI
!$omp end critical
                         endif
!$                       endif
!$               if(C.lt.(Num_threads-1)) then
!$                 C=C+1
!$               else
!$                 C=0
!$               endif
                       LOGIC=.TRUE.
                       exit
                      endif
                     enddo
                    enddo
!$omp end parallel
              endif
              if((10*k/NumCol).gt.iprevious) then 
                write(*,*) 10*(iprevious+1),"%"
                iprevious=10*k/NumCol
              endif                  
             enddo
         endif 

         if(A.eq.1) then !!!
           print*," "
           write(*,'(A26,F16.4,A17)') "SUM OF MARGINAL ENTROPIES:",SUMA(A)," (cal/mol-Kelvin)"
         elseif(A.eq.2) THEN
           WRITE(*,'(I6,A20,F16.4)') A,"nd-ORDER CORRECTION:",SUMA(A)
         elseif(A.eq.3) THEN
           WRITE(*,'(I6,A20,F16.4)') A,"rd-ORDER CORRECTION:",SUMA(A)
         else
           WRITE(*,'(I6,A20,F16.4)') A,"th-ORDER CORRECTION:",SUMA(A)
         endif

      enddo

      do I=1,MaxOrder
        ENTROPY(I)=0.0
      enddo
      
      do I=1,MaxOrder
        if(I.eq.1) then
         ENTROPY(I)=SUMA(I)
        else 
        ENTROPY(I)=ENTROPY(I-1)+SUMA(I)                       !Finally, obtainig the MIE entropy
        endif                                                 !vs order: ERNTROPY(order)
      enddo
      return
      END SUBROUTINE MIE_CutOff
!-----------------------------------------------------------------------------------------



!*****************************************************************************************
      SUBROUTINE MIE_NoCutOff(N,NumSnap,NumSnapTot,NumCol,MaxOrder,ENTROPY,Estimator)
!*****************************************************************************************
! Compute the MIE conformational entroy without cutoff (infinite cutoff)
!using the new expresion derived in ref.(2):
!
!           _____     _                                  _   
!    (n)    \\       |       ___                          |    ___
!   S  (A) = \\      |       \    ((-1)^i)*binomial{M-k,i}|    \    S(I)
!            //      |       /__                          |    /__
!           //___    |_  i=0,...,n-k                     _| Ic{A1,...,Am}
!         k=1,...,n                                            |I|=k
!
!where n=MaxOrder,M=NumCol and k=A
!-----------------------------------------------------------------------------------------
      use parameters
      implicit none
      !-VARIABLE DEFINITIONS--------------------------------------------------------------
      integer NumCol                                          !Number of columns (dihedrals)
      integer NumSnap                                         !Number of snapshots in the current CALC
      integer NumSnapTot                                      !Total number of snapshots considered
      integer MaxOrder                                        !Order of the MIE expansion
      integer(SMALL),intent(IN):: N(NumSnapTot,NumCol)        !Data matrix
      integer(SMALL) M(NumSnap,MaxOrder)              !!!!               !Auxiliary data matrix
      integer X(NumCol)                                       !Auxiliary vector to generate combinations (subsets)
      real(DP) ENT                                            !Temporal variable used to save entropy values
      real(DP),intent(OUT)::ENTROPY(0:MaxOrder)               !Entropy vs Order: ENTROPY(Order) 
      logical LOGIC                                           !Auxiliary logic variable
      character*8 Estimator                                   !Estimator
      integer I,J,A,I2,I3
      integer COEFF                                           !Coefficient in square brackets in the new 
                                                              !
                                                              !      ___                          
                                                              !      \    ((-1)^i)*binomial{M-k,i}
                                                              !      /__                          
                                                              !  i=0,...,n-k                   
 
                                    
      real(DP) SUMA(MaxOrder)                                 !For a given order k, SUMA(k) is the sum of 
                                                              !the entropies of all the subsets I  of A={A1,...,Am}
                                                              !with cardinality k, i.e.: 
                                                              !    ___
                                                              !    \    S(I) 
                                                              !    /__       
                                                              ! Ic{A1,...,Am}
                                                              !    |I|=k     

!$    integer C,Num_threads,my_thread
!$    integer omp_get_num_threads 
!$    integer omp_get_thread_num
      !-----------------------------------------------------------------------------------



      do A=1,MaxOrder
       SUMA(A)=0.0
      enddo

      do A=1,MaxOrder
         if(A.ge.2) then
         endif
         do I=1,A
          X(I)=I
         enddo
!$omp parallel do private(I3,I2)
                 do I3=1,NumSnap
                     do I2=1,A
                      M(I3,I2)=N(I3,X(I2)) !!!!
                     enddo
                 enddo
!$omp end parallel do
                   CALL ENTRO(M,NumSnap,A,ENT,Estimator) !!!!!
                   SUMA(A)=SUMA(A)+ENT

!$omp parallel private(I,J,LOGIC,I3,I2,M,ENT,my_thread,C) firstprivate(X)
!$       Num_threads=omp_get_num_threads()
!$       my_thread=omp_get_thread_num()
!$       C=0
         LOGIC=.TRUE.
         do while (LOGIC)
          LOGIC=.FALSE.
          do I=A,1,-1
          if(X(I).LT.(I+NumCol-A)) then
            X(I)=X(I)+1
              do J=1,A-I
               X(I+J)=X(I)+J
              enddo
!$               if(my_thread.eq.C) then                    
                 do I3=1,NumSnap
                     do I2=1,A
                      M(I3,I2)=N(I3,X(I2))  !!!!
                     enddo
                 enddo
                 CALL ENTRO(M,NumSnap,A,ENT,Estimator)
!$omp critical
                   SUMA(A)=SUMA(A)+ENT
!$omp end critical
!$               endif

!$               if(C.lt.(Num_threads-1)) then
!$                 C=C+1
!$               else
!$                 C=0
!$               endif

            LOGIC=.TRUE.
            exit
          endif
          enddo
         enddo
!$omp end parallel

              do i=1,A
               ENTROPY(i)=0.0   
              enddo

              do I=1,A
               do J=1,I
                CALL Coefficient(NumCol,I,J,COEFF)
                ENTROPY(I)=ENTROPY(I)+COEFF*SUMA(J)           !Finally, obtainig the MIE entropy
               enddo                                          !vs order: ERNTROPY(order)
              enddo

              if(A.eq.1) then
                print*," "
                write(*,'(A26,F16.4,A17)') "SUM OF MARGINAL ENTROPIES:",ENTROPY(A)," (cal/mol-Kelvin)"
              elseif(A.eq.2) THEN
                WRITE(*,'(I6,A20,F16.4)') A,"nd-ORDER CORRECTION:",ENTROPY(A)-ENTROPY(A-1)
              elseif(A.eq.3) THEN
                WRITE(*,'(I6,A20,F16.4)') A,"rd-ORDER CORRECTION:",ENTROPY(A)-ENTROPY(A-1)
              else
                WRITE(*,'(I6,A20,F16.4)') A,"th-ORDER CORRECTION:",ENTROPY(A)-ENTROPY(A-1)
              endif
      enddo


      RETURN
      END SUBROUTINE MIE_NoCutOff
!-----------------------------------------------------------------------------------------



!*****************************************************************************************
      SUBROUTINE Pseudo_Mutual_Info(X2,MaxOrder,N,NumSnap,NumSnapTot,NumCol,&
                 Pseudo_MI,Estimator)
!*****************************************************************************************
! This subroutine computes what we call the pseudo mutual information of order k. 
!
! The pseudo MI of order k among the k elements of a set J,is the classical MI 
!if k is an odd number and minus MI if k is even,i.e.:
!
!    Pseudo_MI=((-1)^(k-1))*Ik(J)
!
!----------------------------------------------------------------------------------------
      use parameters
      implicit none
      !-VARIABLE DEFINITIONS--------------------------------------------------------------
      integer NumCol                                          !Number of columns (dihedrals)
      integer NumSnap                                         !Number of snapshots in the current CALC
      integer NumSnapTot                                      !Total number of snapshots considered
      integer MaxOrder                                        !Order of the MIE expansion
      integer X2(MaxOrder)                                    !Specifies the subset used to compute the Mutual Info.
      integer X(MaxOrder)                                     !Auxiliary vectors to generate combinations (subsets)
      integer(SMALL),intent(IN):: N(NumSnapTot,NumCol)        !Data matrix
      real(DP) ENT                                            !Temporal variable used to save entropy values
      integer(SMALL) M(NumSnap,MaxOrder)                      !Auxiliary data matrix
      logical LOGIC                                           !Auxiliary logic variable
      character*8 Estimator                                   !Estimator
      integer A,I,I1,I2,I3,J                                  !Counters

      real(DP), intent(out)::Pseudo_MI                        !For a given order k, and a subset J of 
                                                              !k dihedrals, Pseudo_MI=((-1)^(k-1))*Ik(J)
      !-----------------------------------------------------------------------------------

      Pseudo_MI=0.0

      DO A=1,MaxOrder
         DO I=1,A
          X(I)=I
         ENDDO
                 DO I3=1,NumSnap
                     DO I2=1,A
                      M(I3,I2)=N(I3,X2(X(I2)))
                     ENDDO
                 ENDDO
                 CALL ENTRO(M,NumSnap,A,ENT,Estimator)
                 Pseudo_MI=Pseudo_MI+((-1.0)**(MaxOrder+A))*ENT
         LOGIC=.TRUE.
         DO WHILE (LOGIC)
          LOGIC=.FALSE.
          DO I=A,1,-1
          IF(X(I).LT.(I+MaxOrder-A)) THEN
            X(I)=X(I)+1
              DO J=1,A-I
               X(I+J)=X(I)+J
              ENDDO
                 DO I3=1,NumSnap
                     DO I2=1,A
                      M(I3,I2)=N(I3,X2(X(I2)))
                     ENDDO
                 ENDDO
                 CALL ENTRO(M,NumSnap,A,ENT,Estimator)
                 Pseudo_MI=Pseudo_MI+((-1.0)**(MaxOrder+A))*ENT
            LOGIC=.TRUE.
            EXIT
          ENDIF
          ENDDO
         ENDDO
      ENDDO

      RETURN
      END  SUBROUTINE Pseudo_Mutual_Info
!-----------------------------------------------------------------------------------------



!*****************************************************************************************
      SUBROUTINE ENTRO(N,NumSnap,NumCol,Entropy,Estimator)
!*****************************************************************************************
! This subroutine, is the one that actually compute
!entropy values. The methods implemented in other subroutines like MLA_CutOff,MIE_CutOff etc.,
!call this subroutine whenever they need.
!-----------------------------------------------------------------------------------------
      use parameters
      implicit none
      !-VARIABLE DEFINITIONS--------------------------------------------------------------
      integer NumCol                                          !Number of columns (dihedrals)
      integer NumSnap                                         !Number of snapshots in the current CALC
      integer(SMALL) N(NumSnap,NumCol)                        !Input Matrix
      character*8 Estimator                                   !Entropy estimator
      real(DP) Entropy                                        !Entropy (output)
      integer count(NumSnap)                                  !A counter used for absolute frequencies 
      real(DP) p                                              !probability (relative frequency)
      logical same                                            !Auxiliary logical variable 
      real(DP) NumSinglet                                     !Number of singletons (states with only one frame) 
      integer i,j,k,c
      integer(SMALL),dimension (:,:),allocatable :: G(:,:)    !Auxiliary data matrix where is saved 
                                                              !every new conformational state founded
                                                              !in N   
      !-----------------------------------------------------------------------------------

      allocate(G(NumSnap,NumCol))

         c=1
         Entropy=0.0
         count(1)=1

        do i=2,NumSnap
         count(i)=0
        enddo
        do k=1,NumCol
          G(1,k)=N(1,k)                                       !Save the first state in G
        enddo

      do i=2,NumSnap
        do j=c,1,-1
            same=.true.
            do k=1,NumCol
              if(G(j,k).ne.N(i,k)) then
                same=.false.
                exit
              endif
            enddo
            if(same) then                                     !the elements i and j are the same
              count(j)=count(j)+1
              exit
            endif
        enddo
        if(.not.same) then
          c=c+1
          do k=1,NumCol
             G(c,k)=N(i,k)
          enddo
          count(c)=1
        endif
      enddo
 
      deallocate(G)
      
      NumSinglet=0.
      
      do i=1,c
       if(count(i).eq.1) NumSinglet=NumSinglet+1.
      enddo

      if(Estimator.eq."ml") then
        do i=1,c
         p=real(count(i),DP)/NumSnap
         if(p.ne.0) Entropy=Entropy - R * p * LOG(p)
        enddo
      elseif(Estimator.eq."cs") then
        do i=1,c
         p=(1.-(NumSinglet/NumSnap))*&
           (real(count(i),DP)/NumSnap)                        !Note that NumSinglet is real
         if(p.ne.0) &
           Entropy=Entropy-R*( (p * LOG(p) )/(1.-(1.-p)**NumSnap) )
        enddo
      else
        print*, "ERROR: The Estimator is unknown"
        stop
      endif

      return
      END SUBROUTINE ENTRO
!-----------------------------------------------------------------------------------------



!*****************************************************************************************
      SUBROUTINE CheckGeom(X,k,DIST,NumCol,CutOff,GeomOk)
!*****************************************************************************************
! For a given subset J of k elements specified by the vector X, this subroutine checks if
!if all the distances between elements of J are less than CutOff, in such case GeomOk=.true.
!otherwise GeomOk=.false.
!-----------------------------------------------------------------------------------------
      use parameters
      implicit none
      !-VARIABLE DEFINITIONS--------------------------------------------------------------
      real(DP) DIST(NumCol,NumCol)                            !Distance matrix
      integer NumCol                                          !Number of Columns in DIST
      logical,intent(OUT)::GeomOk                             !Output of the subroutine
      real(DP)  CutOff                                        !CutOff
      integer i,j,k
      integer X(k)                                            !Vector whose elements specify
                                                              !which torsions will consider
      !-----------------------------------------------------------------------------------

      GeomOk=.true.

      do i=1,k-1
       do j=i+1,k
         if (DIST(X(i),X(j)).ge.CutOff) then
         GeomOk=.false.
         return
         endif
       enddo
      enddo
      return
      END SUBROUTINE CheckGeom
!-----------------------------------------------------------------------------------------



!*****************************************************************************************
      SUBROUTINE Coefficient(NumCol,MaxOrder,k,COEFF)
!*****************************************************************************************
!This subroutine is used to compute two similar coefficients the one used in the MIE 
!expression
!      ___                          
!      \    ((-1)^i)*binomial{M-k,i} , where n=MaxOrder, M=NumCol and k=k 
!      /__                          
!  i=0,...,n-k                   
!
!and the one used in AMIE, i.e.:
!    ___
!    \   ((-1)**j) binomial{|Li|-k,j},where n=MaxOrder, |Li|=NumCol and k=k
!    /__          
! j=0,...,n-k    
!
!-----------------------------------------------------------------------------------------
      use parameters
      implicit none
      !-VARIABLE DEFINITIONS--------------------------------------------------------------
      INTEGER MAXORDER,k                                      !Maximum order and current order
      integer BIN                                             !Binomial coefficient
      INTEGER COEFF                                           !Output
      INTEGER I,J
      INTEGER NumCol                                          !Number of dihedrals if MIE is used
                                                              !or cardinality of the list Li if 
                                                              !AMIE is used
      !-----------------------------------------------------------------------------------

      COEFF=0.0  
       DO I=0,MAXORDER-k
         BIN=1
            IF(I.eq.0) THEN
            BIN=1
            ELSE
            DO J=1,I
            BIN=BIN*(NumCol-k-J+1)/J
            ENDDO
            ENDIF
          COEFF=COEFF+((-1.0)**I)*BIN 
       ENDDO
      RETURN
      END  SUBROUTINE
!-----------------------------------------------------------------------------------------



!*****************************************************************************************
      SUBROUTINE Get_Best_Ordering(DIST,NumCol,CutOff,X,invX)
!*****************************************************************************************
!This subroutine gives through the variable X, the ordering of the torsions that would
!minimize the additional terms.(see ref(3))
!-----------------------------------------------------------------------------------------
      use parameters
      implicit none
      !-VARIABLE DEFINITIONS--------------------------------------------------------------
      integer NumCol                                          !Number of columns(torsions)
      real(DP) CutOff                                         !Cutoff
      real(DP) DIST(NumCol,NumCol)                            !Distance matrix
      integer, dimension(:), allocatable :: NNeig             !Number of neighbors of the i-elemt 
      integer, dimension(:,:), allocatable :: NList           !Neighbors list
      integer, dimension(:), allocatable :: COUNTER           !Counter   
      logical, dimension(:), allocatable :: Selected          !Auxiliary logical variable
      logical i_selected,j_selected,founded                   !Auxiliary logical variables
      integer i,j,k,c                                         !
      integer X(NumCol)                                       !Output: Vector whose elements indicate the ordering
                                                              !of the columns in MATRIX.dat that would minimize
                                                              !the additional terms

      integer invX(NumCol)                                    !Output: Inverse of X (i.e., invX(X(i))=i for every i)
      !-----------------------------------------------------------------------------------

      allocate(Selected(NumCol))
      allocate(NNeig(NumCol))
      allocate(COUNTER(NumCol))
      allocate(NList(NumCol,NumCol))

      c=0

      do i=1,Numcol
       Selected(i)=.false.
      enddo


      do while(c.lt.NumCol)
         do i=1,NumCol
           NNeig(i)=0
         enddo
         do i=1,NumCol
           COUNTER(i)=0
         enddo

         do i=1,NumCol-1
           do j=i+1,NumCol
             if(Selected(i)) exit
             if((DIST(i,j)<CutOff).and.(.not.Selected(j))) then
                NNeig(i)=NNeig(i)+1
                NNeig(j)=NNeig(j)+1
                NList(i,NNeig(i))=j
                NList(j,NNeig(j))=i
             endif
           enddo
         enddo
         
         do k=1,NumCol
           do i=1,NNeig(k)-1
             do j=i+1,NNeig(k)
               if( DIST(NList(k,i),NList(k,j)) .gt. CutOff )&
                 COUNTER(k)=COUNTER(k)+1
             enddo
           enddo
         enddo

         founded=.false.
         do j=0,((NumCol-1)*(NumCol-2)/2)                     !J is just a counter
           do i=1,NumCol
             if((COUNTER(i)==j).and.(.not.Selected(i))) then !
               c=c+1
               Selected(i)=.true.
               X(c)=i
               invX(i)=c
               founded=.true.
               exit 
             endif
           enddo
           if(founded) exit
         enddo
      enddo  

      deallocate(Selected)
      deallocate(NNeig)
      deallocate(COUNTER)
      deallocate(NList)

      return

      END SUBROUTINE Get_Best_Ordering
!-----------------------------------------------------------------------------------------



!*****************************************************************************************
      SUBROUTINE Get_Neighbors_Info(DIST,NumCol,CutOff,NeigList,NumNeig)
!*****************************************************************************************
! This subroutine computes the final neighbors list for the given cutoff and the optimal
!ordering
!-----------------------------------------------------------------------------------------
      use parameters
      implicit none
      !-VARIABLE DEFINITIONS--------------------------------------------------------------
      integer, intent(IN):: NumCol                            !Number of Columns(Dihedrals)
      integer NeigList(NumCol,NumCol)                         !Final neighbors list
      integer NumNeig(NumCol)                                 !Number of neighbors of the i-element
      integer i,j,C                                           !Counters
      real(DP),intent(IN)::CutOff                             !Cutoff
      real(DP),intent(IN)::DIST(NumCol,NumCol)                !Distance matrix 
      !-----------------------------------------------------------------------------------

      !---INITIATION OF THE NUMBER OF NEIGHBORS
      do i=1,NumCol
        NumNeig(i)=0
      enddo

      !---MAKING THE NEIGHBORS LIST
      do i=1,NumCol
        C=0
        do j=i+1,NumCol
          if(DIST(i,j).lt.CutOff) then
             C=C+1
             NeigList(i,C)=j
             NumNeig(i)= NumNeig(i)+1
          endif
        enddo
      enddo
      return
      END SUBROUTINE Get_Neighbors_Info
!-----------------------------------------------------------------------------------------



!*****************************************************************************************
      SUBROUTINE Read_Options(CutOff,MaxOrder,Method,filedat,filedist,filetable &
      ,NumSnap,NumSnapIni,NumCol,SnapInterval,GivenNumCol,GivenNumSnap,GivenCutoff&
      ,Reorder,Estimator,MakeCorrection,FilterCorrelation)
!*****************************************************************************************
!This subroutine reads all the options that can be given to the 
!program through the command line
!-----------------------------------------------------------------------------------------
      use parameters
      implicit none
      !-VARIABLE DEFINITIONS--------------------------------------------------------------
      integer NumCol                                          !Number of Columns(Dihedrals) selected in MATRIX.dat
      integer NumSnapIni                                      !Initial number of Snapshots
      integer NumSnapTot                                      !Total number of rows(Snapshots) to be considered 
      integer NumSnap                                         !Number of Snapshots used on each CALC 
      integer SnapInterval                                    !Gap in snapshots between consecutive calculations (CALCs)
      integer MaxOrder                                        !Maximum order of expansion (MIE, AMIE, ...)

      logical FilterCorrelation                               !Filter false correlation? (True/False)
                                                              !(Transforms MLA into CC-MLA)

      integer Method                                          !Method, the are 3 possible values for this variable:
                                                              ! 1 - MIE 
                                                              ! 2 - AMIE 
                                                              ! 3 - MLA or CCMLA (Correlation Corrected MLA)
                                                              !The discrimination between the two options in 3
                                                              !is done through the "FilterCorrelation" variable

      logical Reorder                                         !Change the ordering of the dihedrals
                                                              !in order to minimize the additional terms?
                                                              !(True/False)
      real(DP) CutOff                                         !Cutoff
      integer j,i,A,i1,C,k                                    !Counters

      logical MakeCorrection                                  !Eliminate de additional terms up to de given
                                                              !MaxOrder? (True/False)              

      logical GivenNumCol                                     !Is the number of columns (NumCol) specified? (True/False)
      logical GivenNumSnap                                    !Is the number of snapshots specified? (True/False)
      logical GivenCutoff                                     !Is the cutoff specified? (True/False)

      real(DP) RealVar                                        !Auxiliary real variable

      character*60  filedist                                  !Filename of the distance matrix file 
                                                              !Default:reduced_dist_matrix.dat

      character*60  filedat                                   !Filename of the data file (Default: MATRIX.dat).
                                                              !This file contains the discretized evolution
                                                              !of the dihedral angles 

      character*60  filetable                                 !Filename of the file where the results are
                                                              !summarized in table form

      integer ios,idummy,iargc                                !Auxiliary integer variables
      character*8 Estimator                                   !Estimator: Max-Likelihood(-ml) or Chao-Shen(-cs)
      character*60 arg                                        !Dummy character variable
      !-----------------------------------------------------------------------------------

!--READING OPTIONS
      C=0
      do i = 1, iargc()
        call getarg(i, arg)
        if((arg.eq.'-c').or.(arg.eq.'-cutoff')) then
          call getarg(i+1, arg)
          read(arg,*,iostat=ios) CutOff
          if(ios>0) stop "ERROR: Check CutOff. Use -help option for quick help"
          C=C+2
          GivenCutoff=.true.
          call getarg(i, arg)
        elseif((arg.eq.'-o').or.(arg.eq.'-order')) then
          call getarg(i+1, arg)
          read(arg,*,iostat=ios) MaxOrder
          read(arg,*,iostat=ios) RealVar
          if((ios.ne.0).or.(MaxOrder.lt.1).or.(MaxOrder.ne.RealVar)) stop "ERROR: Check order. Use -help option for quick help"
          C=C+2
          call getarg(i, arg)
        elseif(arg.eq.'-mie') then
          Method=1
          C=C+1
        elseif(arg.eq.'-amie') then
          Method=2
          C=C+1
        elseif(arg.eq.'-mla') then
          Method=3
          FilterCorrelation=.false.
          C=C+1
        elseif(arg.eq.'-ccmla') then
          Method=3
          C=C+1
        elseif(arg.eq.'-nor') then
          Reorder=.false.
          C=C+1
        elseif(arg.eq.'-e') then
          MakeCorrection=.true.
          C=C+1
        elseif(arg.eq.'-cs') then
          Estimator="cs"
          C=C+1
        elseif(arg.eq.'-ml') then
          Estimator="ml"
          C=C+1
        elseif((arg.eq.'-d').or.(arg.eq.'-data')) then
          call getarg(i+1,arg)
          read(arg,'(A60)',iostat=ios) filedat
          if(ios.ne.0) stop "ERROR: Check the file name of data matrix. Use -help option for quick help"
          C=C+2
          call getarg(i, arg)
        elseif((arg.eq.'-table').or.(arg.eq.'-t')) then
          call getarg(i+1,arg)
          read(arg,*,iostat=ios) filetable
          if(ios.ne.0) stop "ERROR: Check the table file name. Use -help option for quick help"
          C=C+2
          call getarg(i, arg)
        elseif((arg.eq.'-ns').or.(arg.eq.'-nsnap')) then
          call getarg(i+1, arg)
          read(arg,*,iostat=ios) NumSnapIni
          read(arg,*,iostat=ios) RealVar
          if((ios.ne.0).or.(NumSnapIni.lt.1).or.(NumSnapIni.ne.RealVar)) then
            print*,"ERROR: Check number of snapshots. Use -help option for quick help"
            stop
          else
            C=C+2
            GivenNumSnap=.true.
            call getarg(i+2, arg)
            read(arg,*,iostat=ios) NumSnap
            read(arg,*,iostat=ios) RealVar
            if((ios.ne.0).or.(NumSnap.lt.1).or.(NumSnap.ne.RealVar).or.(NumSnap.lt.NumSnapIni)) then
              NumSnap=NumSnapIni
            else
              call getarg(i+3, arg)
              read(arg,*,iostat=ios) SnapInterval
              read(arg,*,iostat=ios) RealVar
              if((ios.ne.0).or.(SnapInterval.lt.1).or.(SnapInterval.ne.RealVar)) then
                NumSnap=NumSnapIni
              else
                C=C+2
              endif
            endif
          endif
          call getarg(i, arg)
        elseif((arg.eq.'-nc').or.(arg.eq.'-ncol')) then
          call getarg(i+1, arg)
          read(arg,*,iostat=ios) NumCol
          read(arg,*,iostat=ios) RealVar
          if((ios.ne.0).or.(NumCol.lt.1).or.(NumCol.ne.RealVar))& 
            stop "ERROR: Check number of columns. Use -help option for quick help"
          C=C+2
          GivenNumCol=.true.
          call getarg(i, arg)
        elseif(arg.eq.'-dist') then
          call getarg(i+1, arg)
          read(arg,'(A60)',iostat=ios) filedist
          if(ios.ne.0) stop "ERROR: Check the distance matrix file name. Use -help option for quick help"
          C=C+2
        elseif((arg.eq.'-help').or.(arg.eq.'-h')) then
          print*,"QUICK HELP:"
          print*,""
          print*,"SYNOPSIS:" 
          print*,"      cencalc [OPTIONS] [> Output_file.out] "
          print*,""
          print*,"OPTIONS:"
          print*," -c/-cutoff CUTOFF                            Default: 8"
          print*,""
          print*," -ns NUMBER_OF_SNAPSHOTS                      Default: Use all"
          print*,"               The are two ways to do it:"
          print*,"               -One Number                 "
          print*,"               -Three Numbers(From the first"
          print*,"                to the second every the third)"
          print*,""
          print*," -mie          Use MIE approximation          Default: ccmla"
          print*,""
          print*," -amie         Use AMIE method                Default: ccmla"
          print*,""
          print*," -mla          Use GLA method                 Default: ccmla"
          print*,""
          print*," -ccmla        Use CCGLA method               Default: ccmla"
          print*,""
          print*," -t/-table TABLE_FILE_NAME"
          print*,"               Save principal results in"
          print*,"               table_file_name "
          print*,""
          print*," -dist REDUCED_DISTANCE_MATRIX_FILENAME       Default: reduced_dist_matrix.dat"
          print*,""
          print*," -data DATA_MATRIX_FILENAME                   Default: MATRIX.dat"
          print*,""
          print*," -cs           Activate Chao-Shen Estimator   Default: Deactivated"
          print*,"               for Entropy"
          print*,""
          print*," -ml           Activate Maximum Likelihood    Default: Activated"
          print*,"               Estimator for Entropy"
          print*,""
          print*," -o/-order ORDER                              Default:4"
          print*,""
          print*," -e            Eliminate the additional       Default: Deactivated"
          print*,"               terms up to the given order"
          print*,""
          print*," -nor          Do not reorder the data        Default: Deactivated"
          print*,"               Matrix before calculations"
          print*,""
          print*," -nc NUMBER_OF_COLUMNS                        Default: Use all"
          print*,""
          print*," -help         Show this quick help"
          print*,""
          print*,"EXAMPLES:"
          print*,"cencalc > output "
          print*,"cencalc -mie -order 3 -cutoff 9 -ns 10000 100000 5000 > output"
          print*,"cencalc -cutoff 7 -ns 10000 100000 5000 -table ccmla_cut7.tab"
          print*,"cencalc -ns 200000"
          stop
        endif
      enddo
      
      if(iargc().ne.C) stop "ERROR: Check the options. Use -help option for quick help"
      return
      END SUBROUTINE Read_Options
!-----------------------------------------------------------------------------------------



!*****************************************************************************************
      SUBROUTINE Elim_Additional_Terms(N,DIST,NeigList,NumNeig, &
      CutOff,NumSnap,NumSnapTot,NumCol,MaxOrder,MaxNumNeig,CORRECTION,Estimator)
!*****************************************************************************************
! Eliminate the additional terms up to the given order, it can be used in combination with
!AMIE and MLA. It is not recommended in combination with CC-MLA because the corrections
!are not correlation-corrected.
!-----------------------------------------------------------------------------------------
      use parameters
      implicit none
      !-VARIABLE DEFINITIONS--------------------------------------------------------------
      integer,intent(IN):: NumCol                             !Number of COLUMNS(DIHEDRALS)
      integer,intent(IN):: NumSnap                            !Number of snapshots in the current CALC
      integer,intent(IN):: NumSnapTot                         !Total number of snapshots considered
      integer,intent(IN):: MaxOrder                           !Maximum order  
      integer(SMALL),intent(IN):: N(NumSnapTot,NumCol)        !Data matrix
      integer,intent(IN):: NeigList(NumCol,MaxNumNeig)        !Neighbors list
                                                              
      integer X(NumCol)                                       !Auxiliary vectors to generate
      integer Xnew(NumCol)                                    !combinations
                                                              
      integer,intent(IN):: NumNeig(NumCol)                    !Number of neighbors of the i-element
      integer,intent(IN):: MaxNumNeig                         !Maximum number of neighbors observed
      integer j,i,A,i1,k                                      !COUNTERS
      real(DP),intent(OUT)::CORRECTION(MaxOrder)              !Output, correction vs order
      logical LOGIC,GeomOk                                    !Auxiliary logic variables
      real(DP),intent(IN)::DIST(NumCol,NumCol)                !REDUCED DISTANCE MATRIX 
      character*8 Estimator                                   !Estimator
      real(DP),intent(IN):: CutOff                            !Cutoff
      integer iprevious                                       !Auxiliary integer variable

      real(DP) Pseudo_MI                                      !For a given order k, and a subset J of 
                                                              !k dihedrals, Pseudo_MI=((-1)^(k-1))*Ik(J)
                                                              !where Ik(J) is the mutual information (MI)
                                                              !shared among the k dihedrals of J.                           

      real(DP) SUMA(MaxOrder)                                 !For a given order k, SUMA(k) is equal
                                                              !to:
                                                              !  ___               ___        
                                                              !  \    ((-1)^(k-1)) \   Ik(J)
                                                              !  /__               /__  
                                                              !   i               J c Li
                                                              !               J .not.belongs. C(R)    
                                                              !                  |J|=k             
                                                              !(see ref.(1))
                                                              !
!$    integer C,Num_threads,my_thread
!$    integer omp_get_num_threads 
!$    integer omp_get_thread_num
      !-----------------------------------------------------------------------------------

      iprevious=0
      
      do A=1,Maxorder
        CORRECTION(A)=0.0
        SUMA(A)=0
      enddo 
      
      do k=1,NumCol
             do A=3,MaxOrder
              if(A.le.(NumNeig(k)+1)) then
                   do i=1,(A-1)
                    X(i)=i
                   enddo
                   Xnew(1)=k
                   do i=1,(A-1)
                    Xnew(i+1)=NeigList(k,X(i))
                   enddo
                         CALL CheckGeom(Xnew,A,DIST,NumCol,CutOff,GeomOk) 
                         if (.not.GeomOk) then
                           CALL Pseudo_Mutual_Info(Xnew,A,N,NumSnap,NumSnapTot,NumCol,Pseudo_MI,Estimator)  
                           SUMA(A)=SUMA(A)+Pseudo_MI                  
                         endif
!$omp parallel private(i,j,LOGIC,i1,Pseudo_MI,Xnew,my_thread,C,GeomOk) firstprivate(X)
!$       Num_threads=omp_get_num_threads()
!$       my_thread=omp_get_thread_num()
!$       C=0
                    LOGIC=.true.
                    do while (LOGIC)
                     LOGIC=.false.
                     do i=(A-1),1,-1
                      if(X(i).LT.(i+NumNeig(k)-(A-1))) then
                       X(i)=X(i)+1
                         do j=1,(A-1)-i
                          X(i+j)=X(i)+j
                         enddo
!$                     if(my_thread.eq.C) then 
                         Xnew(1)=k
                         do i1=1,(A-1)
                          Xnew(i1+1)=NeigList(k,X(i1))
                         enddo
                         CALL CheckGeom(Xnew,A,DIST,NumCol,CutOff,GeomOk)
                         if (.not.GeomOk) then
                           CALL Pseudo_Mutual_Info(Xnew,A,N,NumSnap,NumSnapTot,NumCol,Pseudo_MI,Estimator)
!$omp critical
                           SUMA(A)=SUMA(A)+Pseudo_MI
!$omp end critical
                         endif
!$                     endif
!$               if(C.lt.(Num_threads-1)) then
!$                 C=C+1
!$               else
!$                 C=0
!$               endif
                       LOGIC=.TRUE.
                       exit
                      endif
                     enddo
                    enddo
!$omp end parallel
              endif
              if((10*k/NumCol).gt.iprevious) then
                write(*,*) 10*(iprevious+1),"%"
                iprevious=10*k/NumCol
              endif
             enddo
      enddo
      
      do I=3,MaxOrder
        CORRECTION(I)=CORRECTION(I-1)+SUMA(I)                 !Finally, obtaining the correction
      enddo                                                   !vs order
      
      return
      END SUBROUTINE Elim_Additional_Terms
!-----------------------------------------------------------------------------------------

!**************************************************************
        SUBROUTINE Randomize_Row(RandRow,NumSnap,idum)
!**************************************************************
        use parameters
        integer NumSnap,i,j,temp
        integer RandRow(NumSnap)
        real rand
        integer(K4B), intent(inout) :: idum         
        idum=-1

        do i=1,NumSnap
          call random_number(rand)
          j=ceiling(rand*(NumSnap-i+1) +  (i-1) )
          temp=RandRow(i)
          RandRow(i)=RandRow(j)
          RandRow(j)=temp
        enddo
        END SUBROUTINE Randomize_Row


!MEJORAS O CAMBIOS RESPECTO A LA VERSION v0.2:
!-----------------------------------
!-Comentarios mas completos
!-Arreglado bug en el calculo CCMLA sin cutoff
!-utilizo el generador de estandar de fortran
!-reinicializo el generador de numeros aleatorios para cada numSnap
!-ya no codifica las filas de MATRIX.dat cuando se utiliza MIE sin cutoff.
! ENTRO_L ya no se utiliza
